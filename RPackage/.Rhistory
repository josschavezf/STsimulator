# add expr-distance interaction
for (tt1 in t2:1) {
if (tt1==0) {break}
#para[grep("spatial_int_dist_", colnames(para))]
r=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_region")))
if (r=="NULL") {r=1}
perturbed.cell.type=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_cell_type_perturbed")))
adjacent.cell.type=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_cell_type_adj")))
int.dist.threshold=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_dist_cutoff")))
GeneID1=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_gene_id1")))
if (GeneID1=="NULL") {
GeneID=eval(parse(text=GeneID1))
} else {GeneID=unlist(strsplit(GeneID1, ","))}
PropOfGenes=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_gene_prop")))
if (PropOfGenes=="NULL") {PropOfGenes=eval(parse(text=PropOfGenes))}
delta.mean=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_mean")))
delta.sd=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_sd")))
beta.all[[(t1+tt1)]]=Add.Distance.Asso.Pattern(ppp.obj=cell_loc_list_i,
sim.count=sim_count,
r=r,
perturbed.cell.type=perturbed.cell.type,
adjacent.cell.type=adjacent.cell.type,
int.dist.threshold=int.dist.threshold,
delta.mean=delta.mean,
delta.sd=delta.sd,
GeneID=GeneID, # Cell A Gene 1--> Cell B
PropOfGenes=PropOfGenes,
seed=seed)
}
# add expr-distance interaction
for (tt1 in t3:1) {
if (tt1==0) {break}
#para[grep("spatial_int_expr_", colnames(para))]
r=eval(parse(text=paste0("spatial_int_expr_",
tt1, "_region")))
if (r=="NULL") {r=1}
perturbed.cell.type=eval(parse(text=paste0("spatial_int_expr_",
tt1, "_cell_type_perturbed")))
adjacent.cell.type=eval(parse(text=paste0("spatial_int_expr_",
tt1, "_cell_type_adj")))
int.dist.threshold=eval(parse(text=paste0("spatial_int_expr_",
tt1, "_dist_cutoff")))
GeneID1=eval(parse(text=paste0("spatial_int_expr_",
tt1, "_gene_id1")))
if (GeneID1=="NULL") {GeneID=eval(parse(text=GeneID1))
} else {GeneID=unlist(strsplit(GeneID1, ","))}
GeneID2=eval(parse(text=paste0("spatial_int_expr_", tt1, "_gene_id2")))
if (GeneID2=="NULL") {GeneIDp=eval(parse(text=GeneID2))
} else {GeneIDp=unlist(strsplit(GeneID2, ","))}
if (is.null(GeneID)) {
GenePairIDMatrix=NULL
} else {GenePairIDMatrix=cbind(GeneID, GeneIDp)}
PropOfGenes=eval(parse(text=paste0("spatial_int_expr_", tt1, "_gene_prop")))
if (PropOfGenes=="NULL") {PropOfGenes=eval(parse(text=PropOfGenes))}
Bidirectional1=eval(parse(text=paste0("spatial_int_expr_",tt1, "_bidirectional")))
Bidirectional=eval(parse(text=Bidirectional1))
delta.mean=eval(parse(text=paste0("spatial_int_expr_", tt1, "_mean")))
delta.sd=eval(parse(text=paste0("spatial_int_expr_",tt1, "_sd")))
beta.all[[(t1+t2+tt1)]]=Add.Expr.Asso.Pattern(ppp.obj=cell_loc_list_i,
sim.count=sim_count,
r=r,
perturbed.cell.type=perturbed.cell.type,
adjacent.cell.type=adjacent.cell.type,
int.dist.threshold=int.dist.threshold,
delta.mean=delta.mean,
delta.sd=delta.sd,
GenePairIDMatrix=GenePairIDMatrix,
PropOfGenes=PropOfGenes,
Bidirectional=Bidirectional,
seed=seed)
}
return(beta.all)
}
# ----------------- ParaFitExpr ---------------
#' ParaFitExpr
#'
#' Fit models for gene expression based on input parameters.
#' @param para Parameters loaded and cleaned from the parameter file using function
#' `ParaDigest`.
#' @param expr Expression data
#' @param feature Cell feature data
#' @param CopulaEst Estimated Gaussian Copula function for gene-gene correlation
#' @param ncores No. of cores for estimation
#' @param save Whether to save the fitted model or not
#' @param save_name Provide the path and name for saving the fitted model
#' @return A list of fitted models for genes in each cell type.
#' @export
#'
ParaFitExpr=function(para, expr, feature,
CopulaEst, ncores=1, save=F, save_name=NULL){
sim_method=ifelse(gene_cor=="TRUE", "copula", "ind")
# fit by input data
model_params=Use_scDesign2_model_params(expr=expr,
feature=feature,
Copula=CopulaEst,
sim_method = sim_method,
region_specific_model=region_specific_model,
ncores=ncores)
if (save==T) {
if (is.null(save_name)) {
save_name=fs::path(path_to_output_dir, output_name)
}
save(model_params,
file=paste0(save_name, "_FitExpr.Rdata"))
}
return(model_params)
}
# ----------------- ParaExpr ---------------
#' Simualte gene expression data based on parameters
#'
#' Simualte gene expression data based on parameters
#' @param para Parameters loaded and cleaned from the parameter file using function
#' `ParaDigest`.
#' @param cell_loc_list Simulated cell location data
#' @param expr Expression data
#' @param feature Cell feature data
#' @param CopulaEst Estimated Gaussian Copula function for gene-gene correlation. Default=NULL.
#' @param all_seeds Seeds for all simulated data
#' @param ncores No. of cores for simulation
#' @param model_params The fitted models of genes, often from `ParaFitExpr` function.
#' @return Simulated gene expression data for each cell.
#' @export
#'
ParaExpr=function(para, cell_loc_list, expr, feature,
CopulaEst=NULL, all_seeds, model_params=NULL, ncores=1){
sim_method=ifelse(gene_cor=="TRUE", "copula", "ind")
# fit by input data
if (is.null(model_params)) {
model_params=ParaFitExpr(para, expr, feature,
CopulaEst, ncores=ncores, save=F)
}
# simulate
for (i in 1:num_simulated_datasets) {
sim_count=Use_scDesign2(ppp.obj=cell_loc_list[[i]],
model_params=model_params,
expr=expr,
feature=feature,
depth_simu_ref_ratio=expr_depth_ratio,
sim_method=sim_method,
region_specific_model=region_specific_model,
seed=all_seeds[[i]])
pattern_list=ParaPattern(para=para, sim_count=sim_count,
cell_loc_list_i=cell_loc_list[[i]],
seed=all_seeds[[i]])
sim_count_update=Pattern.Adj(sim.count=sim_count,
pattern.list=pattern_list,
bond.extreme=T, keep.total.count=T,
integer=T)
output=MergeRegion(points.list=cell_loc_list[[i]],
expr.list=sim_count_update)
expr_pattern=ExprPattern(pattern.list.i=pattern_list) %>% as.data.frame()
print(paste("Finished simulating data", i))
# save
save_name=fs::path(path_to_output_dir, output_name)
if (nrow(expr_pattern)!=0) {
write_tsv(expr_pattern,
file=paste0(save_name, "_expr_pattern_", i, ".tsv"))
}
# multicell?
if (num_spots=="NULL") {
write_tsv(output$meta,
file=paste0(save_name, "_meta_", i, ".tsv"))
write_tsv(as.data.frame(output$count)%>% rownames_to_column("GeneName"),
file=paste0(save_name, "_count_", i, ".tsv"))
} else{
output2=multicell(expr=output$count, cell_feature=output$meta, NoSpot=num_spots)
write_tsv(output2$spot_feature,
file=paste0(save_name, "_meta_", i, ".tsv"))
write_tsv(as.data.frame(output2$count)%>% rownames_to_column("GeneName"),
file=paste0(save_name, "_count_", i, ".tsv"))
}
print(paste("Finished saving data", i))
}
}
cell_loc_list=ParaCellsNoST(para=para,
all_seeds=all_seeds[[1]])
cell_loc_list
# Trim  data (no. of cells) in expr to make the expr estimation faster
ctype=table(feature[,1])
# Copula - from parameter file
CopulaEst=ParaCopula(para=para, expr=expr2,
feature=feature, ncores=ncores)
# ModelFitFile=ParaFitExpr(para=para, expr=expr2, feature=feature,
#                          CopulaEst=CopulaEst, ncores=ncores, save=T)
# Simulate Expr for these cells
if( is.null(ModelFitFile)==F) {
load(ModelFitFile)
} else {model_params=NULL}
ModelFitFile=NULL
# Copula - from parameter file
CopulaEst=ParaCopula(para=para, expr=expr2,
feature=feature, ncores=ncores)
# ModelFitFile=ParaFitExpr(para=para, expr=expr2, feature=feature,
#                          CopulaEst=CopulaEst, ncores=ncores, save=T)
# Simulate Expr for these cells
if( is.null(ModelFitFile)==F) {
load(ModelFitFile)
} else {model_params=NULL}
all_seeds=all_seeds[[1]]
all_seeds
model_params
sim_method=ifelse(gene_cor=="TRUE", "copula", "ind")
# fit by input data
if (is.null(model_params)) {
model_params=ParaFitExpr(para, expr, feature,
CopulaEst, ncores=ncores, save=F)
}
# simulate
dim(expr)
expr
# Load  data
expr=ExprLoad(para)
feature=CellFeatureLoad(para)
colnames(expr)=feature[,1]
print("Finished loading data")
# fit by input data
if (is.null(model_params)) {
model_params=ParaFitExpr(para, expr, feature,
CopulaEst, ncores=ncores, save=F)
}
num_simulated_datasets
i=2
all_seeds
all_seeds[[2]]
all_seeds[2]
sim_count=Use_scDesign2(ppp.obj=cell_loc_list[[i]],
model_params=model_params,
expr=expr,
feature=feature,
depth_simu_ref_ratio=expr_depth_ratio,
sim_method=sim_method,
region_specific_model=region_specific_model,
seed=all_seeds[i])
length(sim_count)
dim(sim_count[[1]])
pattern_list=ParaPattern(para=para, sim_count=sim_count,
cell_loc_list_i=cell_loc_list[[i]],
seed=all_seeds[i])
sim_count_update=Pattern.Adj(sim.count=sim_count,
pattern.list=pattern_list,
bond.extreme=T, keep.total.count=T,
integer=T)
points.list=cell_loc_list[[i]]
expr.list=sim_count_update
K=length(points.list)
# points
x.combine=unlist(lapply(1:K, function(f) points.list[[f]]$x))
x.combine2=round(x.combine, digits=4)
y.combine=unlist(lapply(1:K, function(f) points.list[[f]]$y))
y.combine2=round(y.combine, digits=4)
annotation=unlist(lapply(1:K, function(f) points.list[[f]]$marks))
Cell=paste0("Cell", seq(1, length(x.combine)))
n=sapply(1:K, function(f) points.list[[f]]$n)
points.list
names(points.list)
region=rep(names(points.list), times=n)
region
input="parameter_file-3.tsv"
ParaSimulation(input=input)
library(STsimulator)
detach(para)
detach(para)
detach(para)
library(STsimulator)
input="parameter_file-3.tsv"
ParaSimulation(input=input)
detach(para)
detach(para)
# parallel
ncores=detectCores()-2; registerDoParallel(ncores)
print(paste("No. of Cores in Use:", ncores))
print("Start the simulation")
# Digest parameters
para=ParaDigest(input)
attach(para)
# Load  data
expr=ExprLoad(para)
feature=CellFeatureLoad(para)
colnames(expr)=feature[,1]
print("Finished loading data")
path
if (path==1) {
cell_loc_list=ParaCellsNoST(para=para,
all_seeds=all_seeds[[1]])
}
if (path==2) {
cell_loc_list=ParaCellsST(para=para, feature=feature,
all_seeds=all_seeds[[1]])
}
if (path==3) {
cell_loc_list=ParaExistingCellsST(m=num_simulated_datasets,
feature=feature)
}
unobjects(all_seeds)
rm(all_seeds)
input="parameter_file-3.tsv"
ParaSimulation(input=input)
detach(para)
detach(para)
detach(para)
library(STsimulator)
input="parameter_file-3.tsv"
ParaSimulation(input=input)
input="parameter_file-4.tsv"
ParaSimulation(input=input)
input="parameter_file-4.tsv"
ParaSimulation(input=input)
input="parameter_file-5.tsv"
ParaSimulation(input=input)
# output_meta_1.tsv is not correct.
detach(para)
detach(para)
detach(para)
input="parameter_file-5.tsv"
ParaSimulation(input=input)
# output_meta_1.tsv is not correct.
input="parameter_file-8.tsv"
# parallel
ncores=detectCores()-2; registerDoParallel(ncores)
print(paste("No. of Cores in Use:", ncores))
print("Start the simulation")
# Digest parameters
para=ParaDigest(input)
para
all_seeds
para$all_seeds
attach(para)
# Load  data
expr=ExprLoad(para)
feature=CellFeatureLoad(para)
colnames(expr)=feature[,1]
print("Finished loading data")
all_seeds=all_seeds[[1]]
# determine cell type proportion in each region
cell_type_proportion=vector("list", num_regions);
cell_type_proportion
num_regions
tmp=as.matrix(para[,grep("cell_type_proportion_", colnames(para))])
tmp2=matrix(unlist(strsplit(tmp, ",")), ncol=3, byrow = T)
tmp2
i=1
for (i in 1:num_regions){
cell_type_proportion[[i]]= tmp2%>%
data.frame() %>% filter(X1==i, X3>0) %>%
column_to_rownames("X2") %>% dplyr::select(X3) %>%
transform(X3=as.numeric(X3)) %>% t()
}
cell_type_proportion
cell_type_proportion2=lapply(cell_type_proportion, function(f) f/sum(f))
cell_type_proportion2
cell_location_interactions=vector("list", num_regions);
cell_location_interactions
custom_cell_location_interactions
custom_cell_location_interactions=="TRUE"
grep("cell_interaction_", names(para))
para[,grep("cell_interaction_", names(para))]
matrix(para[,grep("cell_interaction_", names(para))], ncol=1)
tmp2=strsplit(tmp1, split = ",")
tmp1=matrix(para[,grep("cell_interaction_", names(para))], ncol=1)
tmp2=strsplit(tmp1, split = ",")
tmp1
tmp1=list(para[,grep("cell_interaction_", names(para))], ncol=1)
tmp1
list(para[,grep("cell_interaction_", names(para))])
as.list(para[,grep("cell_interaction_", names(para))])
tmp1=as.list(para[,grep("cell_interaction_", names(para))])
strsplit(tmp1, split = ",")
tmp1=matrix(para[,grep("cell_interaction_", names(para))], ncol=1)
dim(tmp1)
tmp1
tmp2=sapply(1:nrow(tmp1), function(f) strsplit(f, split = ","))
tmp2=apply(temp1, 1, function(f) strsplit(f, split = ",")))
tmp2=apply(temp1, 1, function(f) strsplit(f, split = ","))
tmp2=apply(tmp1, 1, function(f) strsplit(f, split = ","))
strsplit(tmp1[1,], split = ",")
tmp1[1,]
tmp1
class(tmp1)
tmp1[1]
tmp1[,1]
tmp1[,1]grep("cell_interaction_", names(para))
grep("cell_interaction_", names(para))
para[,grep("cell_interaction_", names(para))]
a=para[,grep("cell_interaction_", names(para))]
class()
class(a)
class(a[1])
as.matrix(para[,grep("cell_interaction_", names(para))])
tmp1=para[,grep("cell_interaction_", names(para))]%>% as.matrix() %>%
t()
tmp1
tmp2=apply(tmp1, 1, function(f) strsplit(f, split = ","))
tmp2
class(tmp2)
class(tmp1)
tmp3=as.data.frame(matrix(unlist(tmp2),ncol=3,byrow=T))
tmp3
class(tmp3$V3)="numeric"
for ( r in 1:num_regions) {cell_location_interactions[[r]]=tmp3}
}
detach(para)
detach(para)
detach(para)
input="parameter_file-8.tsv"
ParaSimulation(input=input)
detach(para)
rm(all_seeds)
input="parameter_file-8.tsv"
ParaSimulation(input=input)
input="parameter_file-7.tsv"
ParaSimulation(input=input)
detach(para)
detach(para)
# parallel
ncores=detectCores()-2; registerDoParallel(ncores)
print(paste("No. of Cores in Use:", ncores))
print("Start the simulation")
# Digest parameters
para=ParaDigest(input)
attach(para)
# Load  data
expr=ExprLoad(para)
feature=CellFeatureLoad(para)
colnames(expr)=feature[,1]
print("Finished loading data")
all_seeds=all_seeds[[1]]
# determine cell type proportion in each region
cell_type_proportion=vector("list", num_regions);
tmp=as.matrix(para[,grep("cell_type_proportion_", colnames(para))])
tmp2=matrix(unlist(strsplit(tmp, ",")), ncol=3, byrow = T)
for (i in 1:num_regions){
cell_type_proportion[[i]]= tmp2%>%
data.frame() %>% filter(X1==i, X3>0) %>%
column_to_rownames("X2") %>% dplyr::select(X3) %>%
transform(X3=as.numeric(X3)) %>% t()
}
cell_type_proportion2=lapply(cell_type_proportion, function(f) f/sum(f))
# determine cell cell location interactions in each region
cell_location_interactions=vector("list", num_regions);
custom_cell_location_interactions
tmp1=para[,grep("cell_interaction_", names(para))]%>%
as.matrix() %>% t()
tmp2=apply(tmp1, 1, function(f) strsplit(f, split = ","))
tmp3=as.data.frame(matrix(unlist(tmp2),ncol=3,byrow=T))
class(tmp3$V3)="numeric"
tmp3
for ( r in 1:num_regions) {cell_location_interactions[[r]]=tmp3}
cell_location_interactions
num_simulated_cells
win
win=RandomRegionWindow(nRegion=num_regions, seed=seed)
win
cell.prop=cell_type_proportion2
cell.inh.attr.input=cell_location_interactions
same.dis.cutoff =cell_overlap_cutoff
even.distribution.coef=cell_even_distribution
seed=seed
all_seeds
seed=all_seeds[m]
cell.prop
R=length(cell.prop)
cell.loc=vector("list", R);
detach(para)
detach(para)
detach(para)
input="parameter_file-7.tsv"
ParaSimulation(input=input)
detach(para)
input="parameter_file-7.tsv"
ParaSimulation(input=input)
run_interactive_STsimulator()
detach(para)
detach(para)
detach(para)
run_interactive_STsimulator()
parameter_file <- shiny::reactiveVal()
parameter_file
parameter_file(/Users/songxiaoyu152/Dropbox/SpatialTranscriptomics/Paper_Simulator/UseShiny/parameter_file-3.tsv)
rm(all_seeds)
run_interactive_STsimulator()
detach(para)
detach(para)
detach(para)
run_interactive_STsimulator()
rm(list=ls())
library(STsimulator)
setwd("/Users/songxiaoyu152/Dropbox/SpatialTranscriptomics/Paper_Simulator/UseShiny")
run_interactive_STsimulator()
getwd()
run_interactive_STsimulator()
run_interactive_STsimulator()
run_interactive_STsimulator()
detach(para)
detach(para)
detach(para)
detach(para)
detach(para)
detach(para)
detach(para)
detach(para)
rm(list=ls())
library(STsimulator)
setwd("/Users/songxiaoyu152/Dropbox/SpatialTranscriptomics/Paper_Simulator/UseShiny")
run_interactive_STsimulator()
