int.dist.threshold=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_dist_cutoff")))
GeneID1=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_gene_id1")))
if (GeneID1=="NULL") {
GeneID=eval(parse(text=GeneID1))
} else {GeneID=unlist(strsplit(GeneID1, ","))}
PropOfGenes=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_gene_prop")))
if (PropOfGenes=="NULL") {PropOfGenes=eval(parse(text=PropOfGenes))}
delta.mean=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_mean")))
delta.sd=eval(parse(text=paste0("spatial_int_dist_",
tt1, "_sd")))
beta.all[[i]][[(t1+tt1)]]=Add.Distance.Asso.Pattern(ppp.obj=cell_loc_list_i,
sim.count=sim_count,
r=r,
perturbed.cell.type=perturbed.cell.type,
adjacent.cell.type=adjacent.cell.type,
int.dist.threshold=int.dist.threshold,
delta.mean=delta.mean,
delta.sd=delta.sd,
GeneID=GeneID, # Cell A Gene 1--> Cell B
PropOfGenes=PropOfGenes,
seed=seed)
}
tt1
tt1=1
if (tt1==0) {break}
#para[grep("spatial_int_expr_", colnames(para))]
r=eval(parse(text=paste0("spatial_int_expr_",
tt1, "_region")))
if (r=="NULL") {r=1}
r
perturbed.cell.type=eval(parse(text=paste0("spatial_int_expr_",
tt1, "_cell_type_perturbed")))
adjacent.cell.type=eval(parse(text=paste0("spatial_int_expr_",
tt1, "_cell_type_adj")))
int.dist.threshold=eval(parse(text=paste0("spatial_int_expr_",
tt1, "_dist_cutoff")))
GeneID1=eval(parse(text=paste0("spatial_int_expr_",
tt1, "_gene_id1")))
perturbed.cell.type
adjacent.cell.type
int.dist.threshold
class(int.dist.threshold)
GeneID1
if (GeneID1=="NULL") {GeneID=eval(parse(text=GeneID1))
} else {GeneID=unlist(strsplit(GeneID1, ","))}
GeneID
GeneID2=eval(parse(text=paste0("spatial_int_expr_", tt1, "_gene_id2")))
if (GeneID2=="NULL") {GeneIDp=eval(parse(text=GeneID2))
} else {GeneIDp=unlist(strsplit(GeneID2, ","))}
GeneIDp
if (is.null(GeneID)) {
GenePairIDMatrix=NULL
} else {GenePairIDMatrix=cbind(GeneID, GeneIDp)}
PropOfGenes=eval(parse(text=paste0("spatial_int_expr_", tt1, "_gene_prop")))
if (PropOfGenes=="NULL") {PropOfGenes=eval(parse(text=PropOfGenes))}
PropOfGenes
Bidirectional1=eval(parse(text=paste0("spatial_int_expr_",tt1, "_bidirectional")))
Bidirectional=eval(parse(text=Bidirectional1))
Bidirectional1
delta.mean=eval(parse(text=paste0("spatial_int_expr_", tt1, "_mean")))
delta.sd=eval(parse(text=paste0("spatial_int_expr_",tt1, "_sd")))
delta.mean
delta.sd
beta.all[[i]][[(t1+t2+tt1)]]=Add.Expr.Asso.Pattern(ppp.obj=cell_loc_list_i,
sim.count=sim_count,
r=r,
perturbed.cell.type=perturbed.cell.type,
adjacent.cell.type=adjacent.cell.type,
int.dist.threshold=int.dist.threshold,
delta.mean=delta.mean,
delta.sd=delta.sd,
GenePairIDMatrix=GenePairIDMatrix,
PropOfGenes=PropOfGenes,
Bidirectional=Bidirectional,
seed=seed)
ppp.obj=cell_loc_list_i
ppp.obj
sim.count=sim_count
R
r
set.seed(seed*3+194)
R=length(sim.count)
sim.count1=sim.count[[r]]
N=ncol(sim.count1)
G=nrow(sim.count1)
GeneAll=rownames(sim.count1)
R
sim.count1
dim(sim.count1)
N
G
GeneAll
# key matrix
beta.matrix=vector("list", length=R)
for (i in 1:R) {beta.matrix[[i]]=matrix(0, nrow=G,  ncol=ncol(sim.count[[i]]))}
colnames(beta.matrix[[r]])=colnames(sim.count1)
rownames(beta.matrix[[r]])=GeneAll
# spatial info
nbr.idx=Find.Neighbor.Pairs(ppp.obj=ppp.obj[[r]],
interacting.cell.type.pair=c(perturbed.cell.type, adjacent.cell.type),
int.dist.threshold=int.dist.threshold)
ppp.obj=ppp.obj[[r]]
ppp.obj
interacting.cell.type.pair=c(perturbed.cell.type, adjacent.cell.type)
interacting.cell.type.pair
int.dist.threshold=int.dist.threshold
int.dist.threshold
cell.loc=cbind(ppp.obj$x, ppp.obj$y)
lat <- c(50.639342, 50.623727, 50.578924, 50.786729)
lon <- c(10.236543, 10.1896532, 10.587272, 10.776234)
type <- c("A", "A", "B", "C")
df <- data.frame(lat, lon, type)
df
sp.data <- df
set.seed(123)
library(sf)
pts1 <- st_as_sf(x = data.frame(id=seq(1,204467,1),
year=sample(seq(from = 1990, to = 2018, by = 1), size = 204467, replace = TRUE),
xcoord=sample(seq(from = -180, to = 180, by = 1), size = 204467, replace = TRUE),
ycoord=sample(seq(from = -90, to = 90, by = 1), size = 204467, replace = TRUE)),
coords=c("xcoord","ycoord"),crs=4326)
pts2 <- st_as_sf(x = data.frame(id=seq(1,5297,1),
year=sample(seq(from = 1990, to = 2018, by = 1), size = 5297, replace = TRUE),
xcoord=sample(seq(from = -180, to = 180, by = 1), size = 5297, replace = TRUE),
ycoord=sample(seq(from = -90, to = 90, by = 1), size = 5297, replace = TRUE)),
coords=c("xcoord","ycoord"),crs=4326)
pts1
pts2
distmat <- st_distance(pts1,pts2,by_element = FALSE)
cell.loc1=cell.loc[1:3,]
cell.loc2=cell.loc[4:6,]
cell.loc1
cell.loc2
outer(cell.loc1, cell.loc2)
?outer
?pairdist
library(proxy)
dist(cell.loc1, cell.loc2,
method="euclidean")
cell.loc1
cell.loc2
sqrt((-24.67386+-85.62048)^2+(7386.094-7389.341)^2)
sqrt((-24.67386+85.62048)^2+(7386.094-7389.341)^2)
sqrt((24.21659+85.62048)^2+(7388.202-7389.341)^2)
detach("package:proxy", unload = TRUE)
dist(cell.loc1, cell.loc2, method="euclidean")
library(proxy)
cell1.idx=which(ppp.obj$marks==interacting.cell.type.pair[1])
cell2.idx=which(ppp.obj$marks==interacting.cell.type.pair[2])
m=dist(cell.loc[cell1.idx,], cell.loc[cell2.idx,], method="euclidean")
dim(m)
# in neighbor or not?
dmax=max( max(ppp.obj$x)-min(ppp.obj$x), max(ppp.obj$y)-min(ppp.obj$y))
m2=m< (int.dist.threshold*dmax)
length()
int.dist.threshold*dmax
mm=m
m=m[1:5, 1:3]
m
m2=m< (int.dist.threshold*dmax)
m
(int.dist.threshold*dmax)
dmax
neighbo.loc.idx=which(m2 == T, arr.ind = TRUE)
neighbo.loc.idx
?which
x <- big.matrix(10, 2, type='integer', init=-5)
library(bigmemory)
install.packages("bigmemory")
library(bigmemory)
x <- big.matrix(10, 2, type='integer', init=-5)
x
options(bigmemory.allow.dimnames=TRUE)
colnames(x) <- c("alpha", "beta")
is.big.matrix(x)
dim(x)
colnames(x)
rownames(x)
x[,]
x[1:8,1] <- 11:18
colnames(x) <- NULL
x[,]
x<1
x[,]<1
which(x[,]<1, arr.ind=T)
m=as.big.matrix(m)
neighbo.loc.idx=which(m< (int.dist.threshold*dmax), arr.ind = TRUE)
neighbo.loc.idx=which(m[,]< (int.dist.threshold*dmax), arr.ind = TRUE)
neighbo.loc.idx
m=mm
dim(m)
m=as.big.matrix(m)
class(m)
m[1:3, 1:3]
m=as.big.matrix(as.matrix(m))
a=as.matrix(m)
m=as.big.matrix(a)
class(a)
class(m)="matrix"
m[1:3 ,1:3]
m=as.big.matrix(m)
dim(m)
m=mm
neighbo.loc.idx=which(m< (int.dist.threshold*dmax), arr.ind = TRUE)
dist
rm(list=ls())
library(tidyverse)
library(data.table)
library(raster)
library(spatstat)
library(rlist)
library(parallel)
library(doParallel)
library(proxy)
setwd("/Users/songxiaoyu152/Dropbox/SpatialTranscriptomics/Paper_Simulator/Github")
source("RPackage/R/PointSimulator_NoData.R")
source("RPackage/R/PointSimulator_STData.R")
source("RPackage/R/ExprSimulator.R")
setwd("/Users/songxiaoyu152/Dropbox/SpatialTranscriptomics/Paper_Simulator/Github")
source("RPackage/R/PointSimulator_NoData.R")
source("RPackage/R/PointSimulator_STData.R")
source("RPackage/R/ExprSimulator.R")
source("RPackage/R/scDesign2_fit_revised.R")
source("RPackage/R/scDesign2_simulate_revised.R")
source("RPackage/R/ParameterDigest.R")
source("RPackage/R/MultiCell.R")
input="ParameterFile/example3.tsv"
ParaSimulation(input=input)
detach(para)
detach(para)
detach(para)
detach(para)
detach(para)
detach(para)
detach(para)
input="ParameterFile/example3.tsv"
ParaSimulation(input=input)
library(scDesign2)
library(STsimulator)
library(STsimulator)
setwd("/Users/songxiaoyu152/Dropbox/SpatialTranscriptomics/Paper_Simulator/Github")
input="ParameterFile/example3.tsv"
ParaSimulation(input=input)
devtools::document()
library(STsimulator)
?attach
?rgamma
library(STsimulator)
usethis::use_testthat()
use_test()
?multicell
library(STsimulator)
?multicell
library(STsimulator)
?multicell
library(STsimulator)
?ParaSimulation
library(STsimulator)
?ParaSimulation
library(STsimulator)
?ParaSimulation
library(STsimulator)
detach("package:STsimulator", unload = TRUE)
library(STsimulator)
library(STsimulator)
detach("package:STsimulator", unload = TRUE)
library(STsimulator)
library(STsimulator)
?ParaSimulation
library(STsimulator)
library(STsimulator)
?ParaSimulation
detach("package:STsimulator", unload = TRUE)
library(STsimulator)
devtools::document()
rlang::last_trace()
rlang::last_trace(drop = FALSE)
library(STsimulator)
library(STsimulator)
library(STsimulator)
library(STsimulator)
?Use_scDesign2_1region
Use_scDesign2_1region
library(STsimulator)
rm(list=ls())
library(SPACox)
library(survival)
library(fastDummies)
library(mstate)
library(tidyverse)
setwd("/Users/songxiaoyu152/Library/CloudStorage/OneDrive-TheMountSinaiHospital/Paper_ProstateTWAS")
df <- read.csv('Data/fulldata.csv') %>% column_to_rownames("indiv")
# Robert, create a data set for genotype, and a dataset for covariates.
gdf=df[,grep("rs", colnames(df))]
cdf=df[,-grep("rs", colnames(df))]
# y
if (min(cdf$surv_time)==0) {cdf$surv_time=cdf$surv_time+0.00001}
fstatus=cdf$surv
ftime=cdf$surv_time
# cov
rawcols = as.matrix(subset(cdf, select=c('PC1','PC2','PC3','PC4','PC5','PC6',
'PC7','PC8','PC9','PC10',
'agedx','gleason','stage')))
dummy = as.matrix(dummy_cols(as.factor(cdf$imputation_set))[,-1])[,-1]
logpsa = as.matrix(log(cdf$psadx))
dimnames(logpsa)[[2]] <- c('logpsa')
cov = cbind(rawcols,dummy, logpsa)
cname=colnames(cov)
# reformat data for competing risk
tmat <- transMat(x = list(c(2, 3), # dx to dod & dx to doo
c(), c()),  # dod to nothing & doo to nothing
names = c("dx",  "doo", "dod"))
use.SPACox.null = function(fstatus, ftime, cov, cname, tmat ) {
# this code generates data for mult-state model
dat=cbind(ttdoo=ftime, # time to doo
ttdod=ftime, # time to dod
doo=fstatus==1, # event is doo
dod=fstatus==2, # event is dod
cov=cov)
msebmt <- msprep(time = c(NA, "ttdoo", "ttdod"),
status = c(NA,  "doo", "dod"),
trans = tmat,
data=dat,
keep = cname) # change the data into multi-state model format
msebmt <- expand.covs(msebmt, cname, longnames = T)
msebmt$ID=paste0("Sub", seq(1:nrow(msebmt)))
# NULL does not include SNP.2
cname.expand=c(paste0(cname, ".1"), paste0(cname, ".2"))
expr= as.formula(paste("Surv(Tstart, Tstop, status) ~ ",
paste(cname.expand, collapse = "+"),
"+strata(trans)"))
obj.null = SPACox_Null_Model(expr, data=msebmt, pIDs=msebmt$ID, gIDs=msebmt$ID)
return(obj.null)
}
obj.null=use.SPACox.null(fstatus, ftime, cov, cname, tmat)
# this code generates data for mult-state model
dat=cbind(ttdoo=ftime, # time to doo
ttdod=ftime, # time to dod
doo=fstatus==1, # event is doo
dod=fstatus==2, # event is dod
SNP=gdf)
dat[1:3,]
# this code generates data for mult-state model
dat=cbind(ttdoo=ftime, # time to doo
ttdod=ftime, # time to dod
doo=fstatus==1, # event is doo
dod=fstatus==2, # event is dod
gdf)
dat[1:3,]
gname=colnames(gdf)
gname
msebmt <- msprep(time = c(NA, "ttdoo", "ttdod"),
status = c(NA,  "doo", "dod"),
trans = tmat,
data=dat,
keep = gname)
msebmt[1:3,]
msebmt <- expand.covs(msebmt, gname, longnames = T)
msebmt[1:3,]
gname.expand=c(paste0(gname, ".1"), paste0(gname, ".2"))
gname.expand
Geno.mtx=msebmt[,gname.expand]
rownames(Geno.mtx)=msebmt$ID
Geno.mtx[1:3, 1:3]
msebmt$ID=paste0("Sub", seq(1:nrow(msebmt)))
gname.expand=c(paste0(gname, ".1"), paste0(gname, ".2"))
Geno.mtx=msebmt[,gname.expand]
rownames(Geno.mtx)=msebmt$ID
Geno.mtx[1:3,1:3]
SPACox.res = SPACox(obj.null=obj.null, Geno.mtx=Geno.mtx, missing.cutoff=0.95)
class(msebmt)
Geno.mtx=as.matrix(msebmt[,gname.expand])
rownames(Geno.mtx)=msebmt$ID
Geno.mtx[1:3, 1:3]
SPACox.res = SPACox(obj.null=obj.null, Geno.mtx=Geno.mtx, missing.cutoff=0.95)
SPACox.res
obj.null=use.SPACox.null(fstatus, ftime, cov, cname, tmat)
SPACox.res=use.SPACox.alt(fstatus, ftime, gdf,  tmat, obj.null)
use.SPACox.alt = function(fstatus, ftime, gdf,  tmat, obj.null) {
# this code generates data for mult-state model
gname=colnames(gdf)
dat=cbind(ttdoo=ftime, # time to doo
ttdod=ftime, # time to dod
doo=fstatus==1, # event is doo
dod=fstatus==2, # event is dod
gdf)
msebmt <- msprep(time = c(NA, "ttdoo", "ttdod"),
status = c(NA,  "doo", "dod"),
trans = tmat,
data=dat,
keep = gname) # change the data into multi-state model format
msebmt <- expand.covs(msebmt, gname, longnames = T)
msebmt$ID=paste0("Sub", seq(1:nrow(msebmt)))
gname.expand=c(paste0(gname, ".1"), paste0(gname, ".2"))
Geno.mtx=as.matrix(msebmt[,gname.expand])
rownames(Geno.mtx)=msebmt$ID
SPACox.res = SPACox(obj.null=obj.null, Geno.mtx=Geno.mtx, missing.cutoff=0.95)
return(SPACox.res)
}
SPACox.res=use.SPACox.alt(fstatus, ftime, gdf,  tmat, obj.null)
SPACox.res
#NOTE: I changed  fstatus=2 to (dod). Do not need to reorder in your function!
use.SPACox.null = function(fstatus, ftime, cov, cname, tmat ) {
# this code generates data for mult-state model
dat=cbind(ttdoo=ftime, # time to doo
ttdod=ftime, # time to dod
doo=fstatus==1, # event is doo
dod=fstatus==2, # event is dod
cov=cov)
msebmt <- msprep(time = c(NA, "ttdoo", "ttdod"),
status = c(NA,  "doo", "dod"),
trans = tmat,
data=dat,
keep = cname) # change the data into multi-state model format
msebmt <- expand.covs(msebmt, cname, longnames = T)
msebmt$ID=paste0("Sub", seq(1:nrow(msebmt)))
# NULL does not include SNP.2
cname.expand=c(paste0(cname, ".1"), paste0(cname, ".2"))
expr= as.formula(paste("Surv(Tstart, Tstop, status) ~ ",
paste(cname.expand, collapse = "+"),
"+strata(trans)"))
obj.null = SPACox_Null_Model(expr, data=msebmt, pIDs=msebmt$ID, gIDs=msebmt$ID)
return(obj.null)
}
use.SPACox.alt = function(fstatus, ftime, gdf,  tmat, obj.null) {
# this code generates data for mult-state model
gname=colnames(gdf)
dat=cbind(ttdoo=ftime, # time to doo
ttdod=ftime, # time to dod
doo=fstatus==1, # event is doo
dod=fstatus==2, # event is dod
gdf)
msebmt <- msprep(time = c(NA, "ttdoo", "ttdod"),
status = c(NA,  "doo", "dod"),
trans = tmat,
data=dat,
keep = gname) # change the data into multi-state model format
msebmt <- expand.covs(msebmt, gname, longnames = T)
msebmt$ID=paste0("Sub", seq(1:nrow(msebmt)))
gname.expand=c(paste0(gname, ".1"), paste0(gname, ".2"))
Geno.mtx=as.matrix(msebmt[,gname.expand])
rownames(Geno.mtx)=msebmt$ID
SPACox.res = SPACox(obj.null=obj.null, Geno.mtx=Geno.mtx, missing.cutoff=0.95)
return(SPACox.res)
}
use.coxph=function(fstatus, ftime, x, cov,  cname, tmat) {
# this code generates data for mult-state model
dat=cbind(ttdoo=ftime, # time to doo
ttdod=ftime, # time to dod
doo=fstatus==1, # event is doo
dod=fstatus==2, # event is dod
SNP=x,
cov=cov)
colnames(dat)[5]="SNP"
xname=c("SNP", cname)
msebmt <- msprep(time = c(NA, "ttdoo", "ttdod"),
status = c(NA,  "doo", "dod"),
trans = tmat,
data=dat,
keep = xname) # change the data into multi-state model format
msebmt <- expand.covs(msebmt, xname, longnames = T)
xname.expand2=c(paste0(xname, ".1"), paste0(xname, ".2"))
expr2= as.formula(paste("Surv(Tstart, Tstop, status) ~ ",
paste(xname.expand2, collapse = "+"),
"+strata(trans)"))
c0 <- coxph(expr2,
data = msebmt,
method = "breslow")
coef=summary(c0)$coefficients
coef2=coef[rownames(coef) %in% c("SNP.1", "SNP.2"),]
return(coef2)
}
use.SPACox.batch.snp = function(cdf, gdf) {
# y
if (min(cdf$surv_time)==0) {cdf$surv_time=cdf$surv_time+0.00001}
fstatus=cdf$surv
ftime=cdf$surv_time
# cov
rawcols = as.matrix(subset(cdf, select=c('PC1','PC2','PC3','PC4','PC5','PC6',
'PC7','PC8','PC9','PC10',
'agedx','gleason','stage')))
dummy = as.matrix(dummy_cols(as.factor(cdf$imputation_set))[,-1])[,-1]
logpsa = as.matrix(log(cdf$psadx))
dimnames(logpsa)[[2]] <- c('logpsa')
cov = cbind(rawcols,dummy, logpsa)
cname=colnames(cov)
# reformat data for competing risk
tmat <- transMat(x = list(c(2, 3), # dx to dod & dx to doo
c(), c()),  # dod to nothing & doo to nothing
names = c("dx",  "doo", "dod"))
# create null
obj.null=use.SPACox.null(fstatus, ftime, cov, cname, tmat)
SPACox.res=use.SPACox.alt(fstatus, ftime, gdf,  tmat, obj.null)
return(SPACox.res)
}
# Robert, create a data set for genotype, and a dataset for covariates.
gdf=df[,grep("rs", colnames(df))]
cdf=df[,-grep("rs", colnames(df))]
results=use.SPACox.batch.snp(cdf, gdf)
results
setwd("/Users/songxiaoyu152/Library/CloudStorage/OneDrive-TheMountSinaiHospital/Paper_ProstateTWAS")
df <- read.csv('Data/fulldata.csv')
# create a data set for genotype, and a dataset for survival + covariates.
gdf=df[,grep("rs", colnames(df))]
cdf=df[,-grep("rs", colnames(df))]
# run this to get and save the results.
results=use.SPACox.batch.snp(cdf, gdf)
results
